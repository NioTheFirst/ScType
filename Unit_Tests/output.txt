Checking FieldsMapsAndArraysTest
Checking ITypicalOracle
Checking ITypicalTokenWrapper
Finding type for reserveTokenA...
address
prev address? u
global assignment: 1
1
Head Addr: 1
    Norm: 0
    Set: {1}
Finding type for reserveTokenB...
address
prev address? u
global assignment: 2
2
Head Addr: 2
    Norm: 6
    Set: {2}



constructor
Finding type for _reserveTokenA...
address
prev address? u
-999
Head Addr: -999
    Norm: 0
    Set: {-999}
Finding type for _reserveTokenB...
address
prev address? u
-998
Head Addr: -998
    Norm: 6
    Set: {-998}
Param: 0
    num: []
    den: []
    norm: u
    link: _reserveTokenA
    fields: []
    fintype: -1
Param: 1
    num: []
    den: []
    norm: u
    link: _reserveTokenB
    fields: []
    fintype: -1


reserveTokenA_1(address) := _reserveTokenA_1(address)
reserveTokenB_1(address) := _reserveTokenB_1(address)


reserveTokenA_1(address) := _reserveTokenA_1(address)
[i]Type for reserveTokenA

Name: reserveTokenA Function: constructor
Num: 
Den: 
Address: -999
Norm: u
LF: _reserveTokenA
Value: u
Fields: 
Finance Type: undef
Copied reserveTokenA
 To type: None
reserveTokenB_1(address) := _reserveTokenB_1(address)
[i]Type for reserveTokenB

Name: reserveTokenB Function: constructor
Num: 
Den: 
Address: -998
Norm: u
LF: _reserveTokenB
Value: u
Fields: 
Finance Type: undef
Copied reserveTokenB
 To type: None


reserveTokenA_1(address) := _reserveTokenA_1(address)
reserveTokenB_1(address) := _reserveTokenB_1(address)


reserveTokenA_1(address) := _reserveTokenA_1(address)
[i]Type for reserveTokenA

Name: reserveTokenA Function: constructor
Num: 
Den: 
Address: -999
Norm: u
LF: _reserveTokenA
Value: u
Fields: 
Finance Type: undef
Copied reserveTokenA
 To type: None
reserveTokenB_1(address) := _reserveTokenB_1(address)
[i]Type for reserveTokenB

Name: reserveTokenB Function: constructor
Num: 
Den: 
Address: -998
Norm: u
LF: _reserveTokenB
Value: u
Fields: 
Finance Type: undef
Copied reserveTokenB
 To type: None



testFieldGood
Finding type for myfield...
MyField
Param: 0
    num: []
    den: []
    norm: u
    link: None
    fields: []
    fintype: -1


reserveTokenA_2(address) := ϕ(['reserveTokenA_0', 'reserveTokenA_1', 'reserveTokenA_3', 'reserveTokenA_5'])
REF_0(uint256) -> myfield_1.amount
TMP_0 = CONVERT reserveTokenA_2 to ITypicalTokenWrapper
TMP_1(uint256) = HIGH_LEVEL_CALL, dest:TMP_0(ITypicalTokenWrapper), function:balanceOf, arguments:['msg.sender']  
reserveTokenA_3(address) := ϕ(['reserveTokenA_1', 'reserveTokenA_5', 'reserveTokenA_3', 'reserveTokenA_2'])
myfield_2(MyField) := ϕ(['myfield_1'])
REF_0(-> myfield_2) = REF_0 (c)+ TMP_1


reserveTokenA_2(address) := ϕ(['reserveTokenA_0', 'reserveTokenA_1', 'reserveTokenA_3', 'reserveTokenA_5'])
[i]Type for reserveTokenA

Name: reserveTokenA Function: testFieldGood
Num: 
Den: 
Address: u
Norm: u
LF: None
Value: u
Fields: 
Finance Type: undef
REF_0(uint256) -> myfield_1.amount
[i]Type for REF_0

Name: myfield.amount Function: testFieldGood
Num: 
Den: 
Address: u
Norm: u
LF: None
Value: u
Fields: 
Finance Type: undef
TMP_0 = CONVERT reserveTokenA_2 to ITypicalTokenWrapper
Converting reserveTokenA_2

Name: reserveTokenA Function: testFieldGood
Num: -1
Den: -1
Address: 1
Norm: u
LF: reserveTokenA
Value: u
Fields: 
Finance Type: undef
TypicalTokenWrapper
[i]Type for TMP_0

Name: TMP_0 Function: testFieldGood
Num: -1
Den: -1
Address: 1
Norm: u
LF: TypicalTokenWrapper
Value: u
Fields: 
Finance Type: undef
TMP_1(uint256) = HIGH_LEVEL_CALL, dest:TMP_0(ITypicalTokenWrapper), function:balanceOf, arguments:['msg.sender']  
Written func info: TypicalTokenWrapper, balanceOf
Handling balance function!
1
