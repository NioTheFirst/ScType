"function _deposit(uint256 _amount) internal override {
        // We receive bCVX -> Convert to bCVX
        CVX_VAULT.withdraw(_amount);

        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));

        // Lock tokens for 17 weeks, send credit to strat, always use max boost cause why not?
        LOCKER.lock(address(this), toDeposit, LOCKER.maximumBoostPayment());
    }"
Balance: "_amount"
Reserve: "toDeposit"

#UNUSED
"function _withdrawSome(uint256 _amount)
        internal
        override
        returns (uint256)
    {
        uint256 max = IERC20Upgradeable(want).balanceOf(address(this));

        if (withdrawalSafetyCheck) {
            uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimals
            require(bCVXToCVX > 10**18, "Loss Of Peg"); // Avoid trying to redeem for less / loss of peg
            require(
                max >= _amount.mul(9_980).div(MAX_BPS),
                "Withdrawal Safety Check"
            ); // 20 BP of slippage
        }

        if (max < _amount) {
            return max;
        }

        return _amount;
    }"
Balance: "_amount"
Reserve: "max"
Price: "bCXToCVX"

"/// @dev used to manage the governance and strategist fee on earned rewards, make sure to use it to get paid!
    function _processRewardsFees(uint256 _amount, address _token)
        internal
        returns (uint256 governanceRewardsFee, uint256 strategistRewardsFee)
    {
        governanceRewardsFee = _processFee(
            _token,
            _amount,
            performanceFeeGovernance,
            IController(controller).rewards()
        );

        strategistRewardsFee = _processFee(
            _token,
            _amount,
            performanceFeeStrategist,
            strategist
        );
    }"
Balance: "_amount"
Fee: "governanceRewardsFee", "strategistRewardsFee"

#UNUSED
"/// @dev Take all CVX and deposits in the CVX_VAULT
    function manualDepositCVXIntoVault() external whenNotPaused {
        _onlyGovernance();

        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));
        if (toDeposit > 0) {
            CVX_VAULT.deposit(toDeposit);
        }
    }"
Reserve: "toDeposit"

"/// @dev Send all available bCVX to the Vault
    /// @notice you can do this so you can earn again (re-lock), or just to add to the redemption pool
    function manualSendbCVXToVault() external whenNotPaused {
        _onlyGovernance();
        uint256 bCvxAmount = IERC20Upgradeable(want).balanceOf(address(this));
        _transferToVault(bCvxAmount);
    }"
Reserve: "bCvxAmount"

"/// @dev Deposit ibBTC to mint wibBTC shares
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }"
Balance: "_shares"

"function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares ("non-rebased balances")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, "ERC20: transfer amount exceeds allowance"));
        return true;
    }"
Balance: "amount", "amountInShares"

"function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares ("non-rebased balances")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }"
Balance: "amount", "amountInShares"

"function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare);
    }"
Balance: balance
Price: pricePerShare

"function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }"
Balance: : "_shares"

"function _transferToFundingPools(uint256 _citadelAmount) internal {
        uint256 length = fundingPools.length();
        // Use cached to save 96 gas per loop read
        uint256 cachedTotalFundingPoolWeight = totalFundingPoolWeight;

        require(length > 0, "CitadelMinter: no funding pools");
        for (uint256 i; i < length; ++i) {
            address pool = fundingPools.at(i);
            uint256 weight = fundingPoolWeights[pool];

            uint256 amount = (_citadelAmount * weight) /
                cachedTotalFundingPoolWeight;

            IERC20Upgradeable(address(citadelToken)).safeTransfer(pool, amount);

            emit CitadelDistributionToFundingPool(
                lastMintTimestamp,
                block.timestamp,
                pool,
                amount
            );
        }
    }"
Reserve: "_citadelAmount", "amount"

"function deposit(uint256 _assetAmountIn, uint256 _minCitadelOut)
        external
        onlyWhenPriceNotFlagged
        gacPausable
        nonReentrant
        returns (uint256 citadelAmount_)
    {
        require(_assetAmountIn > 0, "_assetAmountIn must not be 0");
        require(
            funding.assetCumulativeFunded + _assetAmountIn <= funding.assetCap,
            "asset funding cap exceeded"
        );
        funding.assetCumulativeFunded = funding.assetCumulativeFunded + _assetAmountIn;
        // Take in asset from user
        citadelAmount_ = getAmountOut(_assetAmountIn);
        require(citadelAmount_ >= _minCitadelOut, "minCitadelOut");

        asset.safeTransferFrom(msg.sender, saleRecipient, _assetAmountIn);

        // Deposit xCitadel and send to user
        // TODO: Check gas costs. How does this relate to market buying if you do want to deposit to xCTDL?
        xCitadel.depositFor(msg.sender, citadelAmount_);

        emit Deposit(
            msg.sender,
            _assetAmountIn,
            citadelAmount_
        );
    }"
    Balance: "_assetAmountIn", "citadelAmountIn_"

    "function updateCitadelPriceInAsset(uint256 _citadelPriceInAsset)
        external
        gacPausable
        onlyCitadelPriceInAssetOracle
    {
        require(_citadelPriceInAsset > 0, "citadel price must not be zero");

        if (
            _citadelPriceInAsset < minCitadelPriceInAsset ||
            _citadelPriceInAsset > maxCitadelPriceInAsset
        ) {
            citadelPriceFlag = true;
            emit CitadelPriceFlag(
                _citadelPriceInAsset,
                minCitadelPriceInAsset,
                maxCitadelPriceInAsset
            );
        } else {
            citadelPriceInAsset = _citadelPriceInAsset;
            emit CitadelPriceInAssetUpdated(_citadelPriceInAsset);
        }
    }"
    Price: "_citadelPriceInAsset"