/// <reference types="node" />
import { TypedData } from './types';
/**
 * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once
 * in the resulting array.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @param {string[]} [dependencies]
 * @return {string[]}
 */
export declare const getDependencies: (typedData: TypedData, type: string, dependencies?: string[]) => string[];
/**
 * Encode a type to a string. All dependant types are alphabetically sorted.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @return {string}
 */
export declare const encodeType: (typedData: TypedData, type: string) => string;
/**
 * Get a type string as hash.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @return {BufferEncoding}
 */
export declare const getTypeHash: (typedData: TypedData, type: string) => Buffer;
/**
 * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All
 * dependant types are automatically encoded.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @param {Record<string, any>} data
 * @return {Buffer}
 */
export declare const encodeData: (typedData: TypedData, type: string, data: Record<string, unknown>) => Buffer;
/**
 * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant
 * types are automatically encoded.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @param {Record<string, any>} data
 * @return {Buffer}
 */
export declare const getStructHash: (typedData: TypedData, type: string, data: Record<string, unknown>) => Buffer;
/**
 * Get the EIP-191 encoded message to sign, from the typedData object. If `hash` is enabled, the message will be hashed
 * with Keccak256.
 *
 * @param {TypedData} typedData
 * @param {boolean} hash
 * @return {Buffer}
 */
export declare const getMessage: (typedData: TypedData, hash?: boolean | undefined) => Buffer;
/**
 * Get the typed data as array. This can be useful for encoding the typed data with the contract ABI.
 *
 * @param {TypedData} typedData
 * @param {string} [type]
 * @param data
 * @return {any[]}
 */
export declare const asArray: (typedData: TypedData, type?: string, data?: Record<string, unknown>) => unknown[];
