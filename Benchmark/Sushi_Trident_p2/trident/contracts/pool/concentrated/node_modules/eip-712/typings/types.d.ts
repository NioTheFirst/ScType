import { StructType } from 'superstruct';
export declare const TYPE_REGEX: RegExp;
export declare const ARRAY_REGEX: RegExp;
export declare const BYTES_REGEX: RegExp;
export declare const NUMBER_REGEX: RegExp;
export declare const STATIC_TYPES: string[];
export declare const EIP_712_TYPE: import("superstruct").Struct<{
    name: string;
    type: string;
}, {
    name: import("superstruct").Struct<string, any>;
    type: import("superstruct").Struct<string, any>;
}>;
/**
 * A single type, as part of a struct. The `type` field can be any of the EIP-712 supported types. Currently those are:
 * - Atomic types: bytes1..32, uint8..256, int8..256, bool, address
 * - Dynamic types: bytes, string
 * - Reference types: array type (e.g. uint8[], SomeStruct[]), struct type (e.g. SomeStruct)
 *
 * Note that the `uint` and `int` aliases like in Solidity, and fixed point numbers are not supported by the EIP-712
 * standard.
 */
export declare type EIP712Type = StructType<typeof EIP_712_TYPE>;
export declare const EIP_712_DOMAIN_TYPE: import("superstruct").Struct<{
    name?: string | undefined;
    version?: string | undefined;
    chainId?: string | number | undefined;
    verifyingContract?: string | undefined;
    salt?: string | number[] | undefined;
}, {
    name: import("superstruct").Struct<string | undefined, any>;
    version: import("superstruct").Struct<string | undefined, any>;
    chainId: import("superstruct").Struct<string | number | undefined, any>;
    verifyingContract: import("superstruct").Struct<string | undefined, any>;
    salt: import("superstruct").Struct<string | number[] | undefined, any>;
}>;
/**
 * The EIP712 domain struct. Any of these fields are optional, but it must contain at least one field.
 */
export declare type EIP712Domain = StructType<typeof EIP_712_DOMAIN_TYPE>;
export declare const EIP_712_TYPED_DATA_TYPE: import("superstruct").Struct<{
    types: {
        EIP712Domain: {
            name: string;
            type: string;
        }[];
    } & Record<string, {
        name: string;
        type: string;
    }[]>;
    primaryType: string;
    domain: {
        name?: string | undefined;
        version?: string | undefined;
        chainId?: string | number | undefined;
        verifyingContract?: string | undefined;
        salt?: string | number[] | undefined;
    };
    message: Record<string, unknown>;
}, {
    types: import("superstruct").Struct<{
        EIP712Domain: {
            name: string;
            type: string;
        }[];
    } & Record<string, {
        name: string;
        type: string;
    }[]>, any>;
    primaryType: import("superstruct").Struct<string, any>;
    domain: import("superstruct").Struct<{
        name?: string | undefined;
        version?: string | undefined;
        chainId?: string | number | undefined;
        verifyingContract?: string | undefined;
        salt?: string | number[] | undefined;
    }, {
        name: import("superstruct").Struct<string | undefined, any>;
        version: import("superstruct").Struct<string | undefined, any>;
        chainId: import("superstruct").Struct<string | number | undefined, any>;
        verifyingContract: import("superstruct").Struct<string | undefined, any>;
        salt: import("superstruct").Struct<string | number[] | undefined, any>;
    }>;
    message: import("superstruct").Struct<Record<string, unknown>, any>;
}>;
/**
 * The complete typed data, with all the structs, domain data, primary type of the message, and the message itself.
 */
export declare type TypedData = StructType<typeof EIP_712_TYPED_DATA_TYPE>;
/**
 * Checks if a type is valid with the given `typedData`. The following types are valid:
 * - Atomic types: bytes1..32, uint8..256, int8..256, bool, address
 * - Dynamic types: bytes, string
 * - Reference types: array type (e.g. uint8[], SomeStruct[]), struct type (e.g. SomeStruct)
 *
 * The `uint` and `int` aliases like in Solidity are not supported. Fixed point numbers are not supported.
 *
 * @param {Record<string, unknown>} types
 * @param {string} type
 * @return {boolean}
 */
export declare const isValidType: (types: Record<string, unknown>, type: string) => boolean;
