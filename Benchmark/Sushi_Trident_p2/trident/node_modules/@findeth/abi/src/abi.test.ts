import { decode, encode } from './abi';
import { toHex } from './utils/buffer';

describe('encode', () => {
  it('encodes simple values', () => {
    expect(toHex(encode(['uint256', 'uint256'], [12345, 12345]))).toBe(
      '00000000000000000000000000000000000000000000000000000000000030390000000000000000000000000000000000000000000000000000000000003039'
    );
  });

  it('encodes array values', () => {
    expect(toHex(encode(['uint256', 'uint256[]', 'uint256'], [12345, [67890, 67890], 12345]))).toBe(
      '000000000000000000000000000000000000000000000000000000000000303900000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000003039000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000109320000000000000000000000000000000000000000000000000000000000010932'
    );
    expect(toHex(encode(['string[]'], ['foo', 'bar', 'baz']))).toBe(
      '00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001660000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016f00000000000000000000000000000000000000000000000000000000000000'
    );
  });

  it('encodes nested values', () => {
    expect(
      toHex(
        encode(
          ['uint256', 'uint256[][]', 'uint256'],
          [
            12345,
            [
              [54321, 12345],
              [67890, 98760]
            ],
            12345
          ]
        )
      )
    ).toBe(
      '0000000000000000000000000000000000000000000000000000000000003039000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000030390000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000d43100000000000000000000000000000000000000000000000000000000000030390000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000001093200000000000000000000000000000000000000000000000000000000000181c8'
    );
  });

  it('encodes bytes values', () => {
    const bytes = Buffer.from('123456789abcdef123456789abcdef123456789abcdef', 'hex').toString('hex');
    expect(toHex(encode(['bytes'], [bytes]))).toBe(
      '00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000016123456789abcdef123456789abcdef123456789abcde00000000000000000000'
    );
  });

  it('encodes string values', () => {
    const string = 'foo bar baz qux quux corge';
    expect(toHex(encode(['string'], [string]))).toBe(
      '0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a666f6f206261722062617a20717578207175757820636f726765000000000000'
    );
  });
});

describe('decode', () => {
  it('decodes a token transfer', () => {
    const buffer = Buffer.from(
      '0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000003039',
      'hex'
    );
    expect(decode(['address', 'uint256'], buffer)).toStrictEqual([
      '0x6b175474e89094c44da98b954eedeac495271d0f',
      12345n
    ]);
  });

  it('decodes array values', () => {
    const buffer = Buffer.from(
      '000000000000000000000000000000000000000000000000000000000000303900000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000003039000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000109320000000000000000000000000000000000000000000000000000000000010932',
      'hex'
    );
    expect(decode(['uint256', 'uint256[]', 'uint256'], buffer)).toStrictEqual([12345n, [67890n, 67890n], 12345n]);
    // TODO
    // expect(decode(['string[]'], Buffer.from('00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001660000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016f00000000000000000000000000000000000000000000000000000000000000', 'hex')))
    //  .toStrictEqual(['foo', 'bar', 'baz']);
  });
});
